{% extends "base.html" %}
{% block content %}
<div class="container my-4" style="max-width: 1100px;">

  <!-- Toolbar sticky + responsive -->
  <div class="card bg-dark border-secondary mb-3" id="logs-toolbar">
    <div class="card-body">
      <form id="controls" class="row row-cols-1 row-cols-sm-auto g-2 align-items-center">
        <div class="col">
          <label class="col-form-label text-light control-label" for="level">Niveau</label>
          <select id="level" class="form-select">
            <option>DEBUG</option>
            <option selected>INFO</option>
            <option>WARNING</option>
            <option>ERROR</option>
            <option>CRITICAL</option>
          </select>
        </div>

        <div class="col">
          <label class="col-form-label text-light control-label" for="filter">Filtre (regex)</label>
          <input id="filter" class="form-control" placeholder="Filtre regex (ex: MQTT|ERROR)" />
        </div>

        <div class="col d-flex gap-2">
          <button class="btn btn-primary flex-fill" id="apply" type="button">Appliquer</button>
          <button class="btn btn-secondary flex-fill" id="pause" type="button" data-paused="false">‚è∏Ô∏è Pause</button>
          <button class="btn btn-outline-light flex-fill" id="clear" type="button">üßπ Clear</button>
        </div>

        <div class="col">
          <div class="form-check form-switch mt-1">
            <input class="form-check-input" type="checkbox" id="autoscroll" checked>
            <label class="form-check-label text-light" for="autoscroll">Autoscroll</label>
          </div>
        </div>
      </form>
    </div>
  </div>

  <div class="card bg-black border-secondary">
    <div id="log-container" class="card-body p-2">
      <pre id="log" class="m-0 text-light"></pre>
    </div>
  </div>
</div>

<style>
  /* Toolbar sticky en haut */
  #logs-toolbar { position: sticky; top: 0; z-index: 1030; }

  /* Zone log : meilleure occupation sur mobile (dynamic viewport) */
  #log-container { 
    height: 60dvh;               /* mobile-friendly */
    overflow: auto;
    font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, monospace; 
    font-size: 0.92rem;
  }
  /* Wrap des longues lignes (URLs, traces) */
  #log { 
    white-space: pre-wrap; 
    word-wrap: break-word; 
    word-break: break-word;
  }

  /* Compactage des contr√¥les sur petits √©crans */
  @media (max-width: 576px) {
    .control-label { display: none; }
    .btn, .form-select, .form-control { padding-top: .4rem; padding-bottom: .4rem; }
  }
</style>

<script>
(function() {
  let es = null;
  let paused = false;
  const logEl = document.getElementById('log');
  const levelEl = document.getElementById('level');
  const filterEl = document.getElementById('filter');
  const pauseBtn = document.getElementById('pause');
  const clearBtn = document.getElementById('clear');
  const applyBtn = document.getElementById('apply');
  const autoscrollEl = document.getElementById('autoscroll');

  // Buffer d'affichage pour limiter le nombre d'op√©rations DOM (performances)
  let renderBuffer = [];
  let flushScheduled = false;
  function scheduleFlush() {
    if (flushScheduled) return;
    flushScheduled = true;
    setTimeout(() => {
      flushScheduled = false;
      if (paused || renderBuffer.length === 0) { renderBuffer = []; return; }
      logEl.textContent += renderBuffer.join("\n") + "\n";
      renderBuffer = [];
      if (autoscrollEl.checked) {
        logEl.parentElement.scrollTop = logEl.parentElement.scrollHeight;
      }
    }, 50); // flush toutes les ~50ms
  }

  function appendLine(line) {
    if (paused) return;
    renderBuffer.push(line);
    scheduleFlush();
  }

  function connect() {
    if (es) es.close();
    const params = new URLSearchParams();
    params.set('level', levelEl.value);
    const q = filterEl.value.trim();
    if (q) params.set('q', q);
    es = new EventSource(`/logs/stream?` + params.toString());
    es.onmessage = (ev) => appendLine(ev.data);
    es.onerror = () => { setTimeout(connect, 1000); es.close(); };
  }

  function resetAndConnect() {
    logEl.textContent = ""; // reset affichage : le serveur renverra l'historique filtr√©
    renderBuffer = [];
    connect();
  }

  // Reconnecte automatiquement quand le niveau change
  levelEl.addEventListener('change', resetAndConnect);

  // Debounce sur le filtre (reconnecte 400ms apr√®s la derni√®re frappe)
  let filterTimer = null;
  filterEl.addEventListener('input', () => {
    clearTimeout(filterTimer);
    filterTimer = setTimeout(resetAndConnect, 400);
  });

  // Le bouton "Appliquer" reste disponible
  applyBtn.addEventListener('click', resetAndConnect);

  pauseBtn.addEventListener('click', () => {
    paused = !paused;
    pauseBtn.dataset.paused = String(paused);
    pauseBtn.textContent = paused ? "‚ñ∂Ô∏è Reprendre" : "‚è∏Ô∏è Pause";
  });

  clearBtn.addEventListener('click', () => {
    logEl.textContent = "";
    renderBuffer = [];
  });

  // Connexion initiale
  connect();
})();
</script>
{% endblock %}
